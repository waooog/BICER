package ca.uwaterloo.ece.bicer;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Set;

import org.junit.Test;
import ca.uwaterloo.ece.bicer.data.BIChange;
import ca.uwaterloo.ece.bicer.utils.Utils;

/*
 * This Java source file was auto generated by running 'gradle init --type java-library'
 * by 'j22nam' at '27/05/16 5:45 PM' with Gradle 2.13
 *
 * @author j22nam, @date 27/05/16 5:45 PM
 */
public class ResultValidationTest {
    @Test public void testSomeLibraryMethod() {
    	
    	String project ="lucene";
    	String dir = System.getProperty("user.home") + "/Documents/ODP/projects/" + project +"/";
        
    	String pathForBIChanges = dir + "biChanges.txt";
    	String pathForBIChangesSanitized = dir + "biChangesSanitized.txt";
    	/* BI_SHA1 PATH    BIDATE  FixDAT
    	 * and
    	 * Noisy BI changes
    	 * BI_SHA1 PATH    BIDATE  FixDATE  DUE_TO isAddedLine   line
    	 */
    	String pathForBIChangesNoiseFiltered =  dir + "biChangesNoiseFiltered.txt"; 
    	//String pathForBIManuallyVerified = dir + project + "BIs.txt";
    	String pathForBIManuallyVerified = dir + project + "BIsManualIssueCorrected.txt";
    	
    	ArrayList<BIChange> biChanges = loadBIChanges(pathForBIChanges, true);
    	ArrayList<BIChange> biChangesSanitized = loadBIChanges(pathForBIChangesSanitized, false);
    	
    	if(biChanges.size()!=biChangesSanitized.size()){
    		System.err.println("FATAL: the number of changes must be same between the original and sanitized data");
    		System.exit(0);
    	}else{
    		// check their lines are same by index
    		for(int i=0;i<biChanges.size();i++){
    			if(!biChanges.get(i).getLine().equals(biChangesSanitized.get(i).getLine())){
    				System.err.println("FATAL: order of lines are not consistent between origianl and sanitized");
    				System.exit(0);
    			}
    		}
    	}
    		
    	ArrayList<BIChange> biChangesSanitizedNoiseFiltered = getBIChangesNoiseFiltered( Utils.getLines(pathForBIChangesNoiseFiltered, true));
    	ArrayList<BIChange> identifiedAsNoise = getBIChangesIdentifiedAsNoise(Utils.getLines(pathForBIChangesNoiseFiltered, true));
    	Set<String> biSha1AndPathForAllOriginalBICs = getBISha1AndPathFromBILines(Utils.getLines(pathForBIChanges, true));
    	Set<String> biSha1AndPathManuallyVerified = getBISha1AndPath(Utils.getLines(pathForBIManuallyVerified, true));
    	Set<String> biSha1AndPathManuallyVerifiedNoises = getBISha1AndPath(biSha1AndPathForAllOriginalBICs,biSha1AndPathManuallyVerified);
    	
    	
    	// match (2) (3)
    	ArrayList<Integer> correctBIChangeIndexAfterFiltering = new ArrayList<Integer>();
    	for(BIChange biChangeFiltered:biChangesSanitizedNoiseFiltered){
    		for(BIChange biChageSanitized:biChangesSanitized){
    			
    			if(biChangeFiltered.equals(biChageSanitized)){
    				int index = biChangesSanitized.indexOf(biChageSanitized);
    				if(index<0){
    					System.err.println("FATAL: Error when matching biChangesSanitized and biChangesFiltered ");
    					System.exit(0);
    				}
    				correctBIChangeIndexAfterFiltering.add(index);
    			}
    		}
    	}
    	
    	// check
    	
    	// generate biSha1+path from none-sanitized but tool filtered data (1)
    	ArrayList<String> biSha1AndPathFromNoneSanitizedDataToolFiltered = new ArrayList<String>();
    	for(int i=0; i<correctBIChangeIndexAfterFiltering.size();i++){
    		BIChange biChange = biChanges.get(correctBIChangeIndexAfterFiltering.get(i));
    		biSha1AndPathFromNoneSanitizedDataToolFiltered.add(biChange.getBISha1()+ "\t" + biChange.getPath());
    	}
    	
    	// find FP and FN
    	Set<String> FPs = new HashSet<String>(); // Actual noisy BI but the filters could not filter out them
    	Set<String> FNs = new HashSet<String>(); // Real BIs but the filters removed them.
    	Set<String> TPs1 = new HashSet<String>();
    	Set<String> TPs2 = new HashSet<String>();
    	Set<String> TNs = new HashSet<String>();
    	
    	// Find FPs: Actual noisy BI but the filters could not filter out them
    	// Find them in BIChanges still alive after filtering
    	for(String key:biSha1AndPathFromNoneSanitizedDataToolFiltered){
    		
    		if(biSha1AndPathManuallyVerified.contains(key))
    			TPs1.add(key); // since it is a set, key is unique
    		else
    			FPs.add(key);
    	}
    	
    	// Find FNs: Real BIs but the filters removed them.
    	// Find them in BIChanges manually verified but not in the alive BI changes after filtered.
    	for(String key:biSha1AndPathManuallyVerified){
    		if(biSha1AndPathFromNoneSanitizedDataToolFiltered.contains(key))
    			TPs2.add(key); // since it is a set, key is unique
    		else
    			FNs.add(key);
    	}
    	
    	// Find TNs: Real noises and removed correctly
    	
    	
    	// sanity check: TP1 should be same as TP2
    	for(String key:TPs1)
    		if(!TPs2.contains(key)){
    			System.err.println("FATAL: TP1 and TP2 are not same ");
				System.exit(0);
    		}
    	
    	System.out.println("# All BIs: " + biSha1AndPathForAllOriginalBICs.size());
    	System.out.println("# real BIs: " + biSha1AndPathManuallyVerified.size());
    	System.out.println("# real noisy BIs: " + biSha1AndPathManuallyVerifiedNoises.size());
    	
    	System.out.println("# TP BIs: " + TPs1.size());
    	System.out.println("# FN BIs: " + FNs.size());
    	System.out.println("TP+FN=" + (TPs1.size()+FNs.size()) + " This should be same as # real BIs=" + biSha1AndPathManuallyVerified.size());
    	System.out.println("# FP BIs: " + FPs.size());
    	
    	System.out.println("\n\nFalse Negatives that must not be filtered! At least, one BIC line must exist if not to be FN");
    	
    	for(String FN:FNs){
    		System.out.println(FN);
    	}
    	
    	// FN BIC lines. To be TP, at least one following FN BIC lines per key should be alive even after filtering.
    	System.out.println("\nFN BIC lines. To be TP, at least one of following FN BIC lines per key should be alive even after filtering.");
    	for(BIChange noisyBiChange:identifiedAsNoise){
    		int indexFromSenitizedBIs = findBIChange(biChangesSanitized,noisyBiChange);
    		BIChange originalBIChangeIdentifiedAsNoise = biChanges.get(indexFromSenitizedBIs);
    		String key = originalBIChangeIdentifiedAsNoise.getBISha1() + "\t" + originalBIChangeIdentifiedAsNoise.getPath();
    		if(FNs.contains(key))
    			System.out.println("FN (at least, one of lines with the same key must be alive but filtered.):\t" + noisyBiChange.getFilteredDueTo() + "\t" + originalBIChangeIdentifiedAsNoise.getRecord());
    	}
    	
    	System.out.println("\n\nFalse Positives that should be filtered!");
    	
    	for(String FP:FPs){
    		System.out.println(FP);
    	}
    	
    	for(BIChange biChangeAliveAfterFiltering:biChangesSanitizedNoiseFiltered){
    		int indexFromSenitizedBIs = findBIChange(biChangesSanitized,biChangeAliveAfterFiltering);
    		BIChange originalBIChange = biChanges.get(indexFromSenitizedBIs);
    		String key = originalBIChange.getBISha1() + "\t" + originalBIChange.getPath();

    		if(FPs.contains(key))
    			System.out.println("FP (this must be filtered but did not)\t" +  originalBIChange.getRecord());
    	}
    }
    
    private Set<String> getBISha1AndPath(Set<String> biSha1AndPathForAllOriginalBICs,
			Set<String> biSha1AndPathManuallyVerified) {
    	Set<String> keys = new HashSet<String>();
    	
    	for(String key:biSha1AndPathForAllOriginalBICs){
    		if(!biSha1AndPathManuallyVerified.contains(key))
    			keys.add(key);
    	}
    	
		return keys;
	}

	private Set<String> getBISha1AndPath(ArrayList<BIChange> biChanges, ArrayList<BIChange> biChangesSanitized,
			ArrayList<BIChange> identifiedAsNoise) {
		
    	Set<String> keys = new HashSet<String>();
    	
    	for(BIChange noise:identifiedAsNoise){
    		int indexFromTheSanitized = findBIChange(biChangesSanitized,noise);
    		BIChange noiseInOriginal = biChanges.get(indexFromTheSanitized);
    		keys.add(noiseInOriginal.getBISha1() + "\t" + noiseInOriginal.getPath());
    	}
    	
		return keys;
	}

	private int findBIChange(ArrayList<BIChange> biChangesSanitized, BIChange noisyBiChange) {
		
    	for(BIChange biChange:biChangesSanitized){
    		if(biChange.equals(noisyBiChange))
    			return biChangesSanitized.indexOf(biChange);
    	}
    	
		return -1;
	}

	private HashSet<String> getBISha1AndPath(ArrayList<String> lines) {
		HashSet<String> keys = new HashSet<String>();
    	
    	for(String line:lines){
    		keys.add(line);
    	}
    	
		return keys;
	}
	
	private HashSet<String> getBISha1AndPathFromBILines(ArrayList<String> lines) {
		HashSet<String> keys = new HashSet<String>();
    	
    	for(String line:lines){
    		String[] splitLine = line.split("\t");
    		keys.add(splitLine[0] +"\t" + splitLine[2]);
    	}
    	
		return keys;
	}

	private ArrayList<BIChange> getBIChangesNoiseFiltered(ArrayList<String> linesForbiChangesNoiseFiltered) {
		ArrayList<BIChange> biChangesNoiseFiltered = new ArrayList<BIChange>();
		
		for(String line:linesForbiChangesNoiseFiltered){
			if(line.trim().equals(""))
				break;
			
			BIChange biChange = new BIChange(line,false);
			biChangesNoiseFiltered.add(biChange);
		}
		return biChangesNoiseFiltered;
	}

	private ArrayList<BIChange> loadBIChanges(String path,boolean forSanitizer) {
		ArrayList<String> BIChangeInfo = Utils.getLines(path, true); // Sanitizer file does not have header line, so remove it.
		ArrayList<BIChange> biChanges = new ArrayList<BIChange>();
		for(String info: BIChangeInfo){
			biChanges.add(new BIChange(info,forSanitizer));
		}
		
		return biChanges;
	}
	
	private ArrayList<BIChange> getBIChangesIdentifiedAsNoise(ArrayList<String> linesForbiChangesNoiseFiltered) {
		ArrayList<BIChange> biChangesIdentifiedAsNoise = new ArrayList<BIChange>();

		boolean ready = false;
		for(String line:linesForbiChangesNoiseFiltered){
			
			if(line.trim().equals("BI_SHA1	PATH	BIDATE	FixDATE	 DUE_TO")){
					ready=true;
					continue;
			}
			
			if(ready){
				BIChange biChange = new BIChange(line,false);
				
				biChange.setFilteredDueTo(line.split("\t")[10]);
				biChangesIdentifiedAsNoise.add(biChange);
			}
		}
		return biChangesIdentifiedAsNoise;
	}
}
